Generate
* toevoegen != vaste # => weet length niet op voorhand.
* easy merge
* easy concurrent access
* volgorde bewaren

Prune
* easy concurrent access
* easy removal
* 2 tegelijk?
* 



Generate

?

Elk thread krijgt een deel dat hij moet bij generate.
We weten hoeveel comps er bestaan dus elke thread krijgt een array van vaste lengte
om generate networks aan toe te voegen. Op einde hebben we partiele array (door redundantie/unique).

(evt arrayLists MAAR bij verdubbelen lengte nooit over het maximum berekende gaan.
OF  !! -> array en op einde System.arraycopy naar kleinere array die exact fit. <- !!)

//Tellen we aantal netwerken per array op zodat we nieuwe totale N array hebben.
//Deze wordt ingevuld door elke thread zijn stuk te laten overschrijven in zijn stuk van die lengte.




? Kunnen we ipv een hele lange volle array een partiele deelarrays gebruiken?
Ja. Elk blok (bij prune) wordt dan een deelarray; deze zijn niet allemaal even vol maar dt is niet erg.
We kunnen dan ook gemakkelijk deze blokken (deelarrays) naar HDD schrijven en inlezen.


Prune
Assign Subsumes Task Idee:

Elke Blok mag ten alle tijden maar door 1 T verwijdert worden.
aka zet lock op deze removal.

-> Er bestaat een block Queue; hiervan worden de 'locks genomen':
aka men gaat tasks creeeren die in deze block verwijderen.

removal locks.
T1: 1
T2: 2
T3: 3
T4: 4
T5: 5
T6: 6

Elke thread generate zijn eigen subsumes task door de blok die hij heeft geclaimed.
T1
2-1, 3-1, 4-1, 5-1, 6-1
T2
1-2, 3-2, 4-2, 5-2, 6-2
T3
1-3, 2-3, 4-3, 5-3, 6-3
T4
1-4, 2-4, 3-4, 5-4, 6-4
T5
1-5, 2-5, 3-5, 4-5, 6-5
T6
1-6, 2-6, 3-6, 4-6, 5-6

Note: als blok naar geheugen geschreven wordt: trim array. (alle nulls weg)



T2: A < X -> remove X
T1: X < Y -> remove Y; A < X < Y -> A < Y.






??




Memory
