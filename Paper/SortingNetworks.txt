IJCAI-11 Instructions for Authors



 
 




arrows,automata
lemmaLemma
definitieDefinitie





arrows.meta,calc,positioning




frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle=,
  numbers=none,
  numberstyle=gray,
  keywordstyle=,
  commentstyle=,
  stringstyle=,
  breaklines=true,
  breakatwhitespace=true,
  tabsize=1



Sorteernetwerken van Optimale Grootte
Mathias Dekempeneer, Vincent Derkinderen 

Bachelor Informatica

Katholieke Universiteit Leuven 

voornaam.achternaam@student.kuleuven.be






Korte samenvatting van wat we doen en wat de conclusie is.

Verder werken op paper van Codish et al. Sorteer optimal size sorting network.

Tijdsverbetering van x?
Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla



Introductie

Situering + bijdrage.

Sorting Network (high level), Optimal Size (high level), contributies andere papers rond deze twee, enkele getallen rond grootte orde van het probleem, wat er al geprobeerd is (SAT, generate  prune,...), hoe wij het probleem zullen aanpakken (hoe wij prunen (high level)), gebruikte hardware...

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla

Bla


Probleemstelling
Een comparator netwerk  bestaat uit  kanalen en  comparatoren.
Een comparator  verbindt twee verschillende kanalen  en  waarbij .
We nemen  als waarde op kanaal  net voor comparator , deze waarde is een element uit een totaal geordende set. 
De  comparator  vergelijkt de huidige waarden van beide kanalen en plaatst de kleinste waarde op kanaal  en de grootste waarde op kanaal  zodat  en .
De uitvoer van een comparator netwerk verwijst naar de partieel geordende vector .
De invoer wordt voorgesteld door . 

Een sorteernetwerk is een comparator netwerk met als eigenschap dat de uitvoer gesorteerd is ongeacht de invoer.
Een sorteernetwerk  van optimale grootte houdt in dat er geen ander sorteernetwerk  bestaat waarbij . 
Figuur  is een voorbeeld van zo een netwerk waarop ook de werking gedemonstreerd wordt.
Deze figuur toont ook twee parallelle comparatoren  en , comparatoren die geen kanaal gemeenschappelijk hebben en van volgorde omgewisseld kunnen worden.







Om te onderzoeken of een comparator netwerk een sorteernetwerk is, kunnen we gebruik maken van het nul - een principe. 
Dit principe, zoals beschreven volgens Knuth , stelt dat wanneer een comparator netwerk met  kanalen alle  mogelijke sequenties van  - en -en sorteert, het een sorteernetwerk is.
De optimale grootte van een sorteernetwerk met  kanalen is reeds bewezen tot en met  (Tabel  ).













Voor  zijn er bovengrenzen gekend door zowel concrete voorbeelden als de systematische constructie van Batcher . 
De ondergrenzen werden gevonden via bewijzen en lemma  .







Om te bewijzen dat een sorteernetwerk  een sorteernetwerk is van optimale grootte, moeten we bewijzen dat er geen sorteernetwerk  bestaat.
Aangezien  kanalen zorgen voor  verschillende comparatoren, kunnen er  verschillende netwerken gevormd worden met   comparatoren.
Voor  kanalen en  comparatoren betekent dit  verschillende netwerken, dit maakt het overlopen van alle netwerken niet aantrekkelijk.

Door gebruik te maken van symmetrieen willen we snoeien in het aanmaken van deze netwerken.

We gebruiken de genereer- en snoei-methode zoals beschreven door Codish et al. (sectie 3, ).
Deze methode heeft een cyclisch verloop waarbij men bij elke cyclus de set  uitbreidt naar  om vervolgens te snoeien en de set  te bekomen (Figuur ).














Specifiek zullen we vertrekken van een netwerk zonder comparatoren om te eindigen bij  bestaande uit een sorteernetwerk van optimale grootte.
Bij de genereer-stap zullen we aan elk netwerk van  alle mogelijke comparatoren toevoegen zodat .

Bij de snoei-stap zullen we dan netwerken verwijderen volgens het subsumes principe beschreven in definitie .
[Subsumes] 
We zeggen ``Comparator netwerk  subsumes comparator netwerk '' wanneer een permuntatie  bestaat zodat . Dit wordt genoteerd als  om aan te duiden dat er een permutatie  bestaat zodat . 



Wanneer voor comparator netwerk  geldt dat  en er bestaat een sorteernetwerk   van grootte  dan bestaat er ook een sorteernetwerk  van grootte .


Concreet kunnen we de definitie van subsumes en lemma  beschreven door Codish et al.  gebruiken om in te zien dat we netwerken die gesubsumed worden door andere netwerken kunnen verwijderen.
Wanneer een set van netwerken een sorteernetwerk bevat, zal het snoeien van deze set resulteren in het bekomen van het sorteernetwerk.
Dit kan gebruikt worden om de eindigheid van het algoritme aan te tonen.

Het overlopen van alle permutaties om na te gaan of er een permutatie  bestaat zodat , en dus , is een kostelijke bewerking.
Om deze bewerkingen te vermijden en te versnellen, zullen we extra methoden moeten invoeren om snellere beslissingen te maken over het ``subsumen van een ander netwerk''. 

Representatie van comparator netwerken
Bij de representatie van comparator netwerken moeten we rekening houden met geheugengebruik en de mogelijkheid om efficiente bewerkingen te kunnen uitvoeren.
Concreet zullen we comparatoren voorstellen door een sequentie van bits, waarbij twee bits op een staan. Bijvoorbeeld   stelt de comparator  voor bij een netwerk van  kanalen.
Om de hoeveelheid overbodige bits te beperken, zullen we bij de Java implementatie gebruik maken van shorts .
Buiten de comparatoren worden ook de outputs van het netwerk bijgehouden, opgedeeld per aantal 'en. 
In de Java implementatie kiezen we er voor om een comparator netwerk voor te stellen door een tweedimensionale array van shorts, short[][], en laten we de rij van  'en weg.
Een voorbeeld van zo een representatie staat in tabel .















Genereren
r0.12
	
	[b]0.10
	
    		
			3.5
			[red!30] (4.5/,0.5/) -- (6.5/,0.5/) -- (6.5/,7.5/) -- (4.5/,7.5/) -- cycle;
			in 1/, 2/, 3/, 4/, 5/, 6/, 7/
			[thick] (0,) -- ++(7/,0);
			in 1/,1/,1/,2/,1/,3/,1/,4/,1/,5/,1/,6/,2/,2/,2/,4/,3/,3/,3/,6/,4/,1/,4/,7/,5/,6/,5/,7/,6/,1/,6/,5/
			() circle (1.5 pt);
			[thick] (1/,1/) -- (1/,2/);
			[thick] (1/,3/) -- (1/,4/);
			[thick] (1/,5/) -- (1/,6/);
			[thick] (2/,2/) -- (2/,4/);
			[thick] (3/,3/) -- (3/,6/);
			[thick] (4/,1/) -- (4/,7/);
			[thick] (5/,6/) -- (5/,7/);
			[thick] (6/,1/) -- (6/,5/);
		
		Netwerk 1
		
    
    
    [b]0.10
    
		
			3.5
			[red!30] (4.5/,0.5/) -- (6.5/,0.5/) -- (6.5/,7.5/) -- (4.5/,7.5/) -- cycle;
			in 1/, 2/, 3/, 4/, 5/, 6/, 7/
			[thick] (0,) -- ++(7/,0);
			in 1/,1/,1/,2/,1/,3/,1/,4/,1/,5/,1/,6/,2/,2/,2/,4/,3/,3/,3/,6/,4/,1/,4/,7/,6/,6/,6/,7/,5/,1/,5/,5/
			() circle (1.5 pt);
			[thick] (1/,1/) -- (1/,2/);
			[thick] (1/,3/) -- (1/,4/);
			[thick] (1/,5/) -- (1/,6/);
			[thick] (2/,2/) -- (2/,4/);
			[thick] (3/,3/) -- (3/,6/);
			[thick] (4/,1/) -- (4/,7/);
			[thick] (6/,6/) -- (6/,7/);
			[thick] (5/,1/) -- (5/,5/);
		
		Netwerk 2
		
    
    
    

Bij de genereer-stap lopen we over de set  en voegen we bij elk netwerk alle mogelijke comparatoren toe.
Aangezien een netwerk dat wordt uitgebreid met een overbodige comparator, een waarbij de outputs ongewijzigd blijven, gesubsumed zal worden door een uitbreiding van dat netwerk met een niet overbodige comparator, kunnen we deze meteen verwijderen uit de set . 
Alvorens deze beslissing te maken door alle outputs te overlopen, kunnen we ook eerst kijken of de comparator gelijk is aan de vorige in het netwerk.

Wanneer 2 netwerken op de volgorde van hun parallelle comparatoren na gelijk zijn, zoals in figuur  en , zullen deze elkaar subsumen en een van de twee verwijderd worden.
Dit kan reeds bij de generatie-stap gemakkelijk opgevangen worden door bij het toevoegen van een nieuwe comparator x na te gaan of x een kanaal gemeenschappelijk heeft met de vorige comparator (Code ).
[caption=Test op parallelle comparatoren,label=code1]
x  & vorigeComp != 0

Wanneer dit niet het geval is en het dus parallelle comparatoren zijn, kunnen we bijvoorbeeld kiezen om het netwerk weg te gooien waarbij de nieuwe comparator kleiner is dan de vorige comparator.


Tenslotte, na het toevoegen van de comparator, kunnen we de nieuwe outputs berekenen door de huidig bijgehouden outputs te gebruiken als invoer voor de nieuwe comparator.

Snoeien
Bij de snoei-stap lopen we over de set  en verwijderen we alle netwerken die gesubsumed worden door een ander netwerk in de resterende set.
Om het aflopen van alle permutaties te vermijden, en sneller te beslissen of  met  en  twee comparator netwerken, voeren we enkele methoden in.
Zo gebruiken we onder meer lemma , beschreven in de paper van Codish et al..
Bij  kanalen wordt de methode  keer uitgevoerd waarbij  keer een beslissing genomen wordt. 

Wanneer het aantal outputs bij  met  'en () groter is dan bij  weten we dat  met  en  twee comparator netwerken.


Voor lemma  van Codish () introduceren we extra informatie over het comparator netwerk, namelijk  waarbij  en .
Dit representeert de set van posities  waarvoor er een output bestaat in  met  'en waarvoor geldt dat op de  positie van deze output een  voorkomt. Om efficient operaties te kunnen uitvoeren zullen we de posities voorstellen door middel van een bit representatie. Zo zal bijvoorbeeld  inhouden dat er bij de outputs met twee 'en minstens een output bestaat met een  op de  positie, een met een  op de  positie en geen enkel met een  op positie  of . Deze informatie voegen we bij elk netwerk toe in de vorm van een array van shorts, . Elk kanaal  van het netwerk  vereist dan 4 opeenvolgende indices in , zoals te zien in tabel .
Deze informatie slaan we voor elk kanaal  op vanaf index  .











Wanneer voor een comparator netwerk  en  met  kanalen geldt dat  voor  en  dan .


De methode van lemma  wordt bij  kanalen  keer uitgevoerd waarbij  keer een beslissing genomen wordt.



Tenslotte komen we aan het nagaan van de permutaties, een naieve methode zou zijn om alle  permutaties te overlopen.
In de plaats daarvan zullen we enkel permutaties afgaan die voldoen aan lemma .

, .

 
Om de mogelijke permutaties bij te houden zullen we gebruik maken van een voorstelling die te zien is in tabel .
De waarden in een kolom stellen alle mogelijke posities voor die op die plaats kunnen voorkomen.
Wanneer we tabel   gebruiken om de mogelijke permutaties weer te geven dan zullen we permutatie  en   bekomen, waarbij  een eenheidspermutatie zal voorstellen.
Bij het begin van het algoritme zullen we starten met tabel , waarna we lemma  gebruiken om posities te verwijderen.


























We weten namelijk dat als  er bij de gepermuteerde outputs enkel een  kan komen op de plaats waar dit bij  ook het geval is.
Op de plaats waar  een  heeft, kunnen dus enkel de posities komen waar  een  heeft.
Nemen we bijvoorbeeld  en  dan kunnen we tabel  reduceren tot tabel .
We kunnen voor  deze methode doortrekken voor elke  en voor zowel  als .
Wanneer we elke kolom bijhouden door een bit representatie kunnen we gemakkelijk de doorsnede van de mogelijke posities nemen na elke berekening voor een bepaalde  en  door middel van de -operatie. 














Wanneer tijdens het algoritme een kolom leeg zou komen te staan, kunnen we het algoritme stopzetten.
Dit betekent namelijk dat er geen enkele permutatie bestaat die niet door lemma  wordt afgekeurd.
Mocht op het einde een kolom  element hebben, mogen we dit element uit alle andere kolommen verwijderen.
We kunnen nadien ook nagaan of alle elementen minstens eenmaal voorkomen in de hele tabel.
Tot slot gebruiken we de overblijvende permutatietabel om onze mogelijke permutaties, die aan lemma  voldoen, na te gaan. 

Parallellisatie
l0.20

<Picture Gen_Prune_Opbouw.png>
Opbouw parallelle genereer  snoei


Om het algoritme te laten functioneren met meerdere processoren, zullen we enkele aanpassingen doorvoeren.
Bij de overgang van  naar  zal elke thread een aantal netwerken uit  nemen, in ons geval , hierop de genereer-stap uitvoeren en vervolgens binnen de resterende set de snoei-stap uitvoeren.
Op dat moment beschikt elke thread over een set van netwerken met  comparatoren waarop de snoei-stap nog moet worden uitgevoerd ten opzichte van alle andere sets.
Elke thread zal vervolgens zijn set in een gedeelde lijst in het centraal geheugen plaatsen.
Om deze operatie zo efficient mogelijk te maken, vermijden we zowel locks als het moeten vergroten van de lijst. 
Daarom zullen we in het begin van de cyclus zorgen dat deze lijst groot genoeg is en gebruik maken van een variabele die bijhoudt op welke index een volgend netwerk moet worden bijgevoegd.
In onze Java implementatie zullen we voor deze variabele een AtomicInteger gebruiken, deze variabele garandeert een atomische getAndIncrement(int) functie.
Een thread kan deze functie gebruiken om voldoende plaats in de lijst op te eisen voor zijn set door de grootte van zijn set mee te geven als parameter.

Na het toevoegen aan de gedeelde lijst volgt de snoei-stap. Hier zal elke thread subsumes moeten nagaan tussen alle netwerken in zijn set en elk ander reeds toegevoegd netwerk.
Door het (hopelijk) vele verwijderen van netwerken ontstaan er veel opeenvolgende lege plaatsen in de lijst .
Hierdoor zal het algoritme vaak overbodig het netwerk opvragen.
Om dit aantal, dat groter wordt naarmate het aantal kanalen stijgt, te verminderen, introduceren we een manier om deze opeenvolgende lege indices over te slaan. 
Telkens wanneer een lege index wordt gedetecteerd door een thread zal de thread het aantal opeenvolgende lege indices tellen en dit aantal opslaan op de eerste lege plaats in deze reeks.
Wanneer een thread dit getal tegenkomt, kan hij het opgeslagen aantal indices overslaan.




Evaluatie
Het beschreven algoritme, geimplementeerd in Java, vindt voor  kanalen reeds na  uur en  minuten een oplossing.
Bij eerder onderzoek gebeurde dit in ongeveer  dagen  uur en  minuten .
De tijdsmetingen voor het vinden van een sorteernetwerk van  tot en met  kanalen zijn te zien op figuur . Op deze figuur is ook de tijdsmeting van eerder werk te zien.




























Figuur  toont een van de sorteernetwerken voor  kanalen en  comparatoren.









































 


Empirische evaluaties + grafiekjes

Tabel geven van hoeveel beslissingen er op welke plaats genomen worden.
 

Vergelijken runtime voor 9 kanalen met Codish.

Schatting runtime voor 10 kanalen.



































































Conclusies
Conclusie

Conclusie van wat er bereikt is en hoe er verder aan gewerkt kan worden.

Erkenning
De rekeninfrastructuur en dienstverlening gebruikt in dit werk, werd voorzien door het VSC (Vlaams Supercomputer Centrum), gefinancierd door het FWO en de Vlaamse regering - departement EWI.

Professor Dr. Ir. Tom Schrijvers, Katholieke Universiteit Leuven.



named




